<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hui305</title>
    <link>https://hui305.github.io/</link>
    <description>Recent content on hui305</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 25 Oct 2021 20:34:53 +0800</lastBuildDate>
    
        <atom:link href="https://hui305.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode第一题和第三题解析</title>
      <link>https://hui305.github.io/post/leetcode%E7%AC%AC%E4%B8%80%E9%A2%98%E5%92%8C%E7%AC%AC%E4%B8%89%E9%A2%98%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 25 Oct 2021 20:34:53 +0800</pubDate>
      
      <guid>https://hui305.github.io/post/leetcode%E7%AC%AC%E4%B8%80%E9%A2%98%E5%92%8C%E7%AC%AC%E4%B8%89%E9%A2%98%E8%A7%A3%E6%9E%90/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://hui305.github.io/img/SnowyStoat_ZH-CN10848714314.jpg&#34; alt=&#34;SnowyStoat&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;第一题-两数之和&#34;&gt;第一题 两数之和&lt;/h3&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt; &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：&lt;/p&gt;
&lt;p&gt;输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：&lt;/p&gt;
&lt;p&gt;输入：nums = [3,3], target = 6
输出：[0,1]&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;2 &amp;lt;= nums.length &amp;lt;= 104；
-109 &amp;lt;= nums[i] &amp;lt;= 109；
-109 &amp;lt;= target &amp;lt;= 109；
只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？&lt;/p&gt;
&lt;p&gt;解题：&lt;/p&gt;
&lt;p&gt;首先想到的是 两层循环遍历，第一层取一个数，然后第二层，这个数后面的数逐个和这个数相加&lt;/p&gt;
&lt;p&gt;看是否等于目标值！&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++){&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;++){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]+&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]{&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;时间复杂度为O(n^2);&lt;/p&gt;
&lt;p&gt;更好的性能的解法是：利用map，空间换时间&lt;/p&gt;
&lt;p&gt;具体定义一个map，key为nums的值，value为数组的index&lt;/p&gt;
&lt;p&gt;例如 array[0] = 1 就是 map.put(1,0)&lt;/p&gt;
&lt;p&gt;然后遍历数组，使用map.containsKey()查找&lt;/p&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;],&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++){&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;containsKey&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;target&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;])){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]{&lt;/span&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;target&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]),&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nums&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;],&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IllegalArgumentException&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;No two sum solution&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的话，时间复杂度就降为O(n)&lt;/p&gt;
&lt;h3 id=&#34;第三题--无重复字符的最长子串&#34;&gt;第三题  无重复字符的最长子串&lt;/h3&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。&lt;/p&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;wke&amp;rdquo;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;ldquo;pwke&amp;rdquo; 是一个子序列，不是子串。&lt;/p&gt;
&lt;p&gt;示例 4:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;quot;&amp;quot;
输出: 0&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= s.length &amp;lt;= 5 * 104;
s 由英文字母、数字、符号和空格组成&lt;/p&gt;
&lt;p&gt;线性结构！从左到右！不重复子串是连续的！&lt;/p&gt;
&lt;p&gt;计算长度，需要相对位置，开始位置，结束位置。&lt;/p&gt;
&lt;p&gt;如果是用C语言，会想到用两个指针，start end。&lt;/p&gt;
&lt;p&gt;end只会逐个递增，所以用遍历就行。&lt;/p&gt;
&lt;p&gt;start会随着end的遍历而变化，遇到重复，就在之前那个字符出现位置+1&lt;/p&gt;
&lt;p&gt;要记录元素之前已经存在的位置。（用数组或者map喽）&lt;/p&gt;
&lt;p&gt;我们以 abcabcbb为例，一开始 start end都在a（0）位置。然后end向右递增，&lt;/p&gt;
&lt;p&gt;直到（3）位置，a重复，start移到第一个a位置+1；0+1即b（1）位置。&lt;/p&gt;
&lt;p&gt;这里我们要记录字符上一次出现的位置信息。题目规定 s 由英文字母、数字、符号和空格组成&lt;/p&gt;
&lt;p&gt;ASCII码128个。用int数组来解决。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 记录每个字符位置
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;128&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;//初始化每个字符的位置
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 128&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    last&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//字串长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//开始位置
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ascii &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//char字符转化为ascii码数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;index===&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; index&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
	&lt;span style=&#34;color:#75715e&#34;&gt;//判断是否有元素重复，如果有就在重复元素的索引位置+1；
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; last&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;index&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;//重新计算距离，然后和之前的做比较，取最大的。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    res   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;res&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    last&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ascii&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//存当前字符的位置。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果不使用数组，也可以使用map来存储（字符：位置）的映射关系&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lenSubString&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String s&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;

     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//字串长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
     Map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Character&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; subMap &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HashMap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
     &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++){&lt;/span&gt;
         &lt;span style=&#34;color:#75715e&#34;&gt;//重置开始位置
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;subMap&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getOrDefault&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;),-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)+&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
         &lt;span style=&#34;color:#75715e&#34;&gt;//计算和比较字串长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;len&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
         &lt;span style=&#34;color:#75715e&#34;&gt;//放入 字符：位置 映射 关系
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         subMap&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;),&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
     &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Java面试</title>
      <link>https://hui305.github.io/post/interview/java%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Sat, 23 Oct 2021 22:00:40 +0800</pubDate>
      
      <guid>https://hui305.github.io/post/interview/java%E9%9D%A2%E8%AF%95/</guid>
      
        <description>&lt;h2 id=&#34;一个人介绍&#34;&gt;一、个人介绍&lt;/h2&gt;
&lt;h2 id=&#34;二项目经验&#34;&gt;二、项目经验&lt;/h2&gt;
&lt;p&gt;1）最近做什么项目？&lt;/p&gt;
&lt;p&gt;2）具体负责哪些工作？&lt;/p&gt;
&lt;p&gt;3）用到什么技术、组件、框架等？&lt;/p&gt;
&lt;p&gt;根据回答，再问以下问题。&lt;/p&gt;
&lt;h2 id=&#34;三java基础&#34;&gt;三、java基础&lt;/h2&gt;
&lt;h3 id=&#34;集合&#34;&gt;集合&lt;/h3&gt;
&lt;h4 id=&#34;hashmap&#34;&gt;Hashmap&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;jdk1.8 hashmap的数据结构是什么？ （必会）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​     答：数组+链表+红黑树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么要使用红黑树，红黑树有什么性质吗？&lt;/p&gt;
&lt;p&gt;红黑树的特性:
（1）红黑树，顾名思义，节点要么黑，要么红。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径]&lt;/p&gt;
&lt;p&gt;红黑树的时间复杂度为Olog(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hashmap的扩容机制&lt;/p&gt;
&lt;h5 id=&#34;1什么时候才需要扩容&#34;&gt;&lt;strong&gt;1.什么时候才需要扩容&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;在首次调用put方法的时候，初始化数组table&lt;/li&gt;
&lt;li&gt;当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2hashmap的扩容&#34;&gt;2.HashMap的扩容&lt;/h5&gt;
&lt;p&gt;进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。&lt;/p&gt;
&lt;p&gt;HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到&amp;quot;&lt;strong&gt;原位置+旧容量&lt;/strong&gt;&amp;ldquo;这个位置。&lt;/p&gt;
&lt;p&gt;怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5Cresize.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(&lt;strong&gt;原位置+旧容量&lt;/strong&gt;)”。可以看看下图为16扩充为32的resize示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5Chashmap_resize.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。
原文链接：https://blog.csdn.net/qq_29860591/article/details/113726055&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同学去面试京东，被问了一个问题：我们都知道，HashMap是由Entry&lt;a href=&#34;https://so.csdn.net/so/search?q=%E9%93%BE%E8%A1%A8&amp;amp;spm=1001.2101.3001.7020&#34;&gt;链表&lt;/a&gt;组成的数组，当HashMap要在链表里插入新的Entry时，到底是插入头部还是尾部呢？&lt;/p&gt;
&lt;p&gt;答：在jdk1.8 尾查法。在jdk1.8之前头插法&lt;/p&gt;
&lt;h5 id=&#34;java-hashmap方法api&#34;&gt;Java HashMap方法API&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isEmpty()&lt;/td&gt;
&lt;td&gt;判断 hashMap 是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;size()&lt;/td&gt;
&lt;td&gt;计算 hashMap 中键/值对的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;put()&lt;/td&gt;
&lt;td&gt;将键/值对添加到 hashMap 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;putIfAbsent()&lt;/td&gt;
&lt;td&gt;如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;containsKey()&lt;/td&gt;
&lt;td&gt;检查 hashMap 中是否存在指定的 key 对应的映射关系。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;containsValue()&lt;/td&gt;
&lt;td&gt;检查 hashMap 中是否存在指定的 value 对应的映射关系。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getOrDefault()&lt;/td&gt;
&lt;td&gt;获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entrySet()&lt;/td&gt;
&lt;td&gt;返回 hashMap 中所有映射项的集合集合视图。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keySet()&lt;/td&gt;
&lt;td&gt;返回 hashMap 中所有 key 组成的集合视图。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43472877/article/details/110957053?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-110957053-blog-107696811.pc_relevant_recovery_v2&amp;amp;spm=1001.2101.3001.4242.2&amp;amp;utm_relevant_index=3&#34;&gt;https://blog.csdn.net/qq_43472877/article/details/110957053?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-110957053-blog-107696811.pc_relevant_recovery_v2&amp;amp;spm=1001.2101.3001.4242.2&amp;amp;utm_relevant_index=3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;linkedhashmap&#34;&gt;LinkedHashMap&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt; 内部维护了一个双向链表，保持遍历顺序和插入顺序一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;treemap&#34;&gt;TreeMap&lt;/h4&gt;
&lt;p&gt;还有一种&lt;code&gt;Map&lt;/code&gt;，它在内部会对Key进行排序，这种&lt;code&gt;Map&lt;/code&gt;就是&lt;code&gt;SortedMap&lt;/code&gt;。注意到&lt;code&gt;SortedMap&lt;/code&gt;是接口，它的实现类是&lt;code&gt;TreeMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SortedMap&lt;/code&gt;保证遍历时以Key的顺序来进行排序。例如，放入的Key是&lt;code&gt;&amp;quot;apple&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;pear&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;orange&amp;quot;&lt;/code&gt;，遍历的顺序一定是&lt;code&gt;&amp;quot;apple&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;orange&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;pear&amp;quot;&lt;/code&gt;，因为&lt;code&gt;String&lt;/code&gt;默认按字母排序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Main&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        Map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TreeMap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;orange&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;apple&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 2&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pear&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String key &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;keySet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// apple, orange, pear
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TreeMap 的键允许空值吗？&lt;/p&gt;
&lt;p&gt;TreeMap 的key允许为null，但是如果使用默认的比较器，会报空指针异常。&lt;/p&gt;
&lt;p&gt;自定义比较器如果处理了null值就可以。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; Map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TreeMap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;Comparator&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;nullsFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Comparator&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;naturalOrder&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()));&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;arraylist和linkedlist&#34;&gt;Arraylist和Linkedlist&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Arraylist和Linkedlist底层实现上有什么区别？&lt;/p&gt;
&lt;p&gt;答：ArrayList 通过数组实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  LinkedList 底层的数据结构是基于双向循环链表的
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ArrayList的扩容机制了解吗？是不是线程安全的？&lt;/p&gt;
&lt;p&gt;答：每次扩容到原来的1.5倍，ArrayList的线程是不安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;扩容容量的计算:int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1),其中oldCapacity是原来的容量大小，oldCapacity &amp;gt;&amp;gt; 1 为位运算的右移操作，右移一位相当于除以2，所以这句代码就等于int newCapacity = oldCapacity + oldCapacity / 2；即容量扩大为原来的1.5倍
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注：ArrayList扩容是1.5倍，hashmap扩容是2倍！&lt;/p&gt;
&lt;h3 id=&#34;string-字符串处理&#34;&gt;String 字符串处理&lt;/h3&gt;
&lt;h4 id=&#34;string-str-123-string-str--new-string123有什么区别&#34;&gt;String str =“123“， String str = new String（”123）有什么区别？&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
    String s1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    String s2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    String s3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    String s4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    String s5 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; s2&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    String s6 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; s2&lt;span style=&#34;color:#f92672&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;intern&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s3 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s4&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//false
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s3 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s5&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//false
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s4 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s5&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//false
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;s3 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s6&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//true
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;![](D:\bobstone\Pictures\Saved Pictures\20200820154311588.jpg)&lt;/p&gt;
&lt;p&gt;1.常量与常量的拼接结果在常量池。且常量池不会存在相同内容的常量。
2.只要其中一个是变量，结果就在堆中。
3.如果拼接的结果调用intern()方法，返回值就在常量池中。&lt;/p&gt;
&lt;h4 id=&#34;string的charat方法&#34;&gt;String的charAt方法&lt;/h4&gt;
&lt;p&gt;charAt方法：
java.lang.String.charAt()方法 返回 指定索引 处的 char值。索引范围 是从0 到length() - 1。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/419185359&#34;&gt;ASCII码是什么意思？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在计算机中，任何数据都以&lt;strong&gt;二进制&lt;/strong&gt;的形式存储。&lt;/p&gt;
&lt;p&gt;然后很明显地，我们没法用这个东西去真正意义上的存个字母&amp;quot;a&amp;quot;进去，因为再怎么说&lt;a href=&#34;https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1452012086%7D&#34;&gt;二进制数&lt;/a&gt;最后只能落实成数而不是文本。&lt;/p&gt;
&lt;p&gt;这就好像&lt;a href=&#34;https://www.zhihu.com/search?q=%E7%94%B5%E6%8A%A5&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1452012086%7D&#34;&gt;电报&lt;/a&gt;一样，电报只能发送电信号，无论如何也不可能发送一个手写的字母&amp;quot;a&amp;rdquo;，但是我们又需要用这东西传递信息，那么如果我们想用电报表示文本，那就只能对每一个文本进行&lt;strong&gt;编码（Encoding）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;于是才有了类似于&lt;a href=&#34;https://www.zhihu.com/search?q=%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1452012086%7D&#34;&gt;摩斯电码&lt;/a&gt;等等电报编码的方式，这些编码的目的就是把文本转换成数值信号。&lt;/p&gt;
&lt;p&gt;那么对于ASCII也是同理，他是一种把字符编码成二进制的方式：&lt;/p&gt;
&lt;p&gt;因为只有转换成二进制数才能被计算机存储和发送。&lt;/p&gt;
&lt;p&gt;当然ASCII只是一种编码方式而已，当然还有&lt;strong&gt;其他的编码方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作者：Oberon
链接：https://www.zhihu.com/question/419185359/answer/1452012086
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;p&gt;JVM&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5Cjvm.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;JVM的内存结构大概分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;jstat-gcutil&#34;&gt;jstat gcutil&lt;/h4&gt;
&lt;p&gt;当 Java 程序有性能问题时，尤其是响应时间有突然变化时，最好第一时间查看 GC 的状态。一般用 &lt;code&gt;jstat -gcutil &amp;lt;pid&amp;gt; 1s&lt;/code&gt; 来查看，那么它的输出又是什么含义呢？&lt;/p&gt;
&lt;h4 id=&#34;输出样例&#34;&gt;输出样例&lt;/h4&gt;
&lt;p&gt;一般会用两种方式调用 &lt;code&gt;jstat&lt;/code&gt;，一种看百分比，一种看具体数值(KB)。&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;jstat -gcutil &amp;lt;pid&amp;gt; 1s&lt;/code&gt; 会每隔一秒输出内存相关信息，示例输出如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
0.00   0.00  34.47  44.29  93.05  83.49     &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;    0.036     &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;    0.117    0.153
0.00   0.00  45.70  44.29  93.05  83.49     &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;    0.036     &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;    0.117    0.153
0.00   0.00  58.12  44.29  93.05  83.49     &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;    0.036     &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;    0.117    0.153
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;gc-过程简要梳理&#34;&gt;GC 过程简要梳理&lt;/h4&gt;
&lt;p&gt;下图是 GC 过程的概要（图片来源 &lt;a href=&#34;http://plumbr.io/&#34;&gt;plumbr.io&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5Chow-java-garbage-collection-works.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图，JVM 中的内存中的各个区域和作用如下（这里只是概述，细节麻烦查阅相关材料）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt;（伊甸园）：创建新对象时会从中分配内存。内存不足时，触发 Young GC。不再被引用的对象将被抛弃，还被引用的对象会被复制到 Survivor 区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Survivor&lt;/code&gt;（幸存者）：有两个 Survivor 区，GC 时会来回地把内存从其中一个区复制到另一个，交替进行。这里存储的是一些“年轻”的对象，多次 GC （默认 15 次）后这些对象还停留在 Survivor 区，则认为它们会被长期引用，Survivor 空间不足时会将它们移动到“老生代”中。来回复制的过程中除了释放内存，还起到整理内存碎片的作用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tenured&lt;/code&gt;（终生代）、也称 &lt;code&gt;Old Generation&lt;/code&gt;（老生代）：保留那些“长期”被引用的对象。因此该区域只在 Full GC 的时候才会被整理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PermGen&lt;/code&gt;/&lt;code&gt;MetaSpace&lt;/code&gt;，Java 8 前是 PermGen，Java 8 后改成 MetaSpace。用来存储诸如加载的类、字符串常量等元信息，与 GC 无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外：&lt;code&gt;Eden&lt;/code&gt; 与 &lt;code&gt;Survivor&lt;/code&gt; 统称“年轻代”，它们引发的 GC 也称 “Young GC”。Young GC 通常比 Full GC 快很多，如果系统有卡顿，一般需要关注 Full GC。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;h4 id=&#34;jstat-输出含义&#34;&gt;jstat 输出含义&lt;/h4&gt;
&lt;p&gt;了解了 GC 的过程，其实 &lt;code&gt;jstat&lt;/code&gt; 的输出通过查文档 &lt;code&gt;man jstat&lt;/code&gt; 就可以找到。这里权且作个翻译：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-gcutil&lt;/code&gt; 的输出如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Column&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;S0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;第 0 个 survivor（幸存区）使用的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;S1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;第 1 个 survivor（幸存区）使用的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;E&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;Eden&lt;/code&gt; 区使用内存的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;O&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;老生代内存使用的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P/M&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;PermGen&lt;/code&gt;/&lt;code&gt;MetaSpace&lt;/code&gt; 的内存使用百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;YGC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;程序启动以来 Young GC 发生的次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;YGCT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;程序启动以来 Young GC 共消耗的时间(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FGC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;程序启动以来 Full GC 发生的次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FGCT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;程序启动以来 Full GC 共消耗的时间(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GCT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;程序启动以来 GC 的总用时(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;h2 id=&#34;数据库-mysql为主&#34;&gt;数据库 mysql为主&lt;/h2&gt;
&lt;h4 id=&#34;btree相对于b-tree有几点不同&#34;&gt;B+Tree相对于B-Tree有几点不同：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非叶子节点只存储键值信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有叶子节点之间都有一个链指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据记录都存放在叶子节点中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/exyG4YRO-n_wVvg408_lWQ&#34;&gt;闲扯B-Tree和B+Tree的异同&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;同&#34;&gt;同&lt;/h6&gt;
&lt;p&gt;B树和B+树其实都是平衡搜索树。这里要脑补一下平衡搜索树的概念：这个词划分一下就是平衡+搜索+树。也就是说，他首先是一棵树，其次能搜索，再次他是平衡的。大家耳熟能详的一个概念：二叉平衡搜索树。（详细的大家可以在百度上搜一下定义，或者拿起那本厚实的「算法导论」看看）。&lt;/p&gt;
&lt;h6 id=&#34;异&#34;&gt;异&lt;/h6&gt;
&lt;p&gt;我们可以看到B树里面，每个结点有这样的特点：不论是叶结点还是非叶结点，都含有Key和一个指向数据的指针。这样，一旦找到某个结点以后，就可以根据指针找到对应的磁盘地址。&lt;/p&gt;
&lt;p&gt;但是，这也带来了另外的问题，就是每一个数据的指针会带来额外的内存占用，从而减少放入内存的结点数。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们再回头看看B+树，他有两个明显的特征：&lt;/p&gt;
&lt;p&gt;1、所有的叶子结点才有指向数据的指针。非叶结点就是纯的索引数据。这样的好处在于，我们可以将尽可能的非叶结点载入内存，没有浪费。&lt;/p&gt;
&lt;p&gt;2、大家注意看那个红色的箭头，每个叶结点都有指向下一个叶结点的链接。这样的好处在于，我们可以从任意一个叶结点开始遍历，获取接下来所有的数据。&lt;/p&gt;
&lt;h4 id=&#34;innodb存储引擎就是用btree实现其索引结构&#34;&gt;InnoDB存储引擎就是用B+Tree实现其索引结构。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5C0.7305220719195556.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;什么是聚集索引？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clustered Index：聚集索引，又称聚簇索引&lt;/p&gt;
&lt;p&gt;​       聚集索引：指索引项的排序方式和表中数据记录排序方式一致的索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 也就是说聚集索引的顺序就是数据的物理存储顺序。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;什么是回表查询？&lt;/p&gt;
&lt;p&gt;那回表是什么：如果是通过非主键索引进行查询，select所要获取的字段不能通过非主键索引获取到，需要通过非主键索引获取到的主键，从聚集索引再次查询一遍，获取到所要查询的记录，这个查询的过程就是回表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是索引覆盖？&lt;/p&gt;
&lt;p&gt;covering index&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5Cb7719b41-17c7-4cfb-8668-414fff413eef.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;覆盖索引避免了回表现象的产生，从而减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是性能优化的一种手段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引下推(Index Condition Pushdown)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;索引下推就是在查询时，首先只读取索引元组（而不是整行数据），通过索引元组来判断数据是否符合&lt;code&gt;WHERE&lt;/code&gt;语句中的条件，然后只对其中符合条件的行再读取整行数据来进行其他&lt;code&gt;WHERE&lt;/code&gt;条件的判断。&lt;/p&gt;
&lt;p&gt;有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/LU_ZHAO/article/details/105152039&#34;&gt;https://blog.csdn.net/LU_ZHAO/article/details/105152039&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;explain-执行计划&#34;&gt;Explain 执行计划&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cinterview%5C0.7852418917363465.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;id如果相同，可认为是同一组，执行顺序从上到下。&lt;/p&gt;
&lt;p&gt;在所有组中，id值越大执行优先级越高。所以执行顺序为t3-&amp;gt;derived2(衍生表，也可以说临时表)-&amp;gt;t2。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Explain中的“Extra”
2.1 Using where
Extra为Using where说明，SQL使用了where条件过滤数据。

2.2 Using index
Extra为Using index说明，SQL所需要返回的所有列数据均在一棵索引树上，而无需访问实际的行记录。

2.3 Using index condition
Extra为Using index condition说明，确实命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。

2.4 Using filesort
Extra为Using filesort说明，得到所需结果集，需要对所有记录进行文件排序。
典型的，在一个没有建立索引的列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序。

2.5 Using temporary
Extra为Using temporary说明，需要建立临时表(temporary table)来暂存中间结果。
这类SQL语句性能较低，往往也需要进行优化。
典型的，group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;mysql日志&#34;&gt;mysql日志&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;binlog&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    MySQL的二进制日志可以说是MySQL最重要的日志了，它记录了所有的DDL和DML(除了数据查询语句)语句，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;二进制有两个最重要的使用场景: 
    其一：MySQL Replication在Master端开启binlog，Mster把它的二进制日志传递给slaves来达到master-slave数据一致的目的。 -
    其二：自然就是数据恢复了，通过使用mysqlbinlog工具来使恢复数据。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[&lt;a href=&#34;https://www.cnblogs.com/martinzhang/p/3454358.html&#34;&gt;MySQL的binlog日志&lt;/a&gt;](&lt;a href=&#34;https://www.cnblogs.com/martinzhang/p/3454358.html&#34;&gt;https://www.cnblogs.com/martinzhang/p/3454358.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;redo log&lt;/p&gt;
&lt;p&gt;确保事务的持久性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以防在发生故障的时间点，还有脏页未写入磁盘，在重启mysql的时候，根据redo log进行重做，从而达到事务的持久性这一特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;undo log&lt;/p&gt;
&lt;p&gt;　　保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql为什么需要undo log？
1.以下讨论以MySQL的InnoDB引擎为例
2.在InnoDB中，有三种日志跟事务的ACID关系都很大：
undo log负责原子性，保护事务在exception或手动rollback时可以回滚到历史版本数据
redo log负责落盘持久性，保证事务提交后新的数据不会丢失
binlog负责副本持久性，可以将主节点上的数据复制到从节点，主节点crash后业务可以正常运转
3.可以看到， undo log只关心过去，redo log只关心未来
4.楼主提到『如果不提交数据，磁盘中的数据还是更新前的，事务回滚不更新数据就好了』。如果我们只记录一个历史版本数据，其它事务每次都只需要读取到最新版本的数据，的确是这样，这个就是Read Committed
5.但是，如果说你要备份整个数据库，整个事务可能会持续一个小时，同时有大量线上并发修改操作，我相信你一定希望读取到逻辑一致的数据。这时同一行数据就需要支持多个历史版本的数据了，这一招叫MVCC，对应Repeatable Read隔离级别，而记录多个历史版本数据的地方就叫undo log
6.实践中，对于面向个人业务的互联网在线业务，推荐Read Committed；对于分析性业务，推荐Repeatable Read（InnoDB的默认事务隔离级别）
7.InnoDB将undo log作为数据的一部分存储到了redo log中，因此很多时候不太区分它们
8.https://mp.weixin.qq.com/s/V-Calkc3rmhdkH581Qc7rA
作者：普通熊猫
链接：https://www.zhihu.com/question/445644612/answer/1742967478
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;mvcc 多版本并发控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    不同事务对同一行的更新操作&lt;strong&gt;产生多个版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​    通过回滚指针将这些版本链接成一条&lt;strong&gt;Undo Log链&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一致性读的实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RU隔离级别下 ==&amp;gt; 直接读取版本的最新记录。&lt;/li&gt;
&lt;li&gt;SERIALIZABLE隔离级别 ==&amp;gt; 通过加锁互斥访问数据实现。&lt;/li&gt;
&lt;li&gt;RC和RR隔离级别 ==&amp;gt; 使用版本链(ReadView,可读视图)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mysql-filesort原理及优化&#34;&gt;MySQL filesort原理及优化&lt;/h4&gt;
&lt;p&gt;在使用 explain 命令优化&lt;a href=&#34;https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&amp;amp;spm=1001.2101.3001.7020&#34;&gt;SQL语句&lt;/a&gt;的时候常常会在Extra列的描述中发现 Using filesort 选项&lt;/p&gt;
&lt;p&gt;当看到MySQL的explain输出using filesort时，说明排序时没有使用索引。如果输出using temporary;using filesort则说明使用文件排序和磁盘临时表，这种情况需要引起注意，效率会比较低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.那怎么解决呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.我们可以在业务层面解决，例如在自己的代码里面对从数据库取出来的数据进行排序，而不是将这些都交给数据库来做。&lt;/p&gt;
&lt;p&gt;2.当Where 条件和 order by 子句作用在不同的列上，建立联合索引可以避免Using filesort的产生。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/PERCENTILE__/article/details/120576699?spm=1001.2101.3001.6650.1&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120576699-blog-4251624.pc_relevant_multi_platform_whitelistv3&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120576699-blog-4251624.pc_relevant_multi_platform_whitelistv3&amp;amp;utm_relevant_index=2&#34;&gt;using filesort优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/SeekN/article/details/121029208?spm=1001.2101.3001.6650.5&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-121029208-blog-120576699.t5_layer_eslanding_D_4&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-121029208-blog-120576699.t5_layer_eslanding_D_4&amp;amp;utm_relevant_index=6&#34;&gt;Mysql之Using filesort优化&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;缓存-redis&#34;&gt;缓存 redis&lt;/h2&gt;
&lt;h4 id=&#34;redis缓存更新策略&#34;&gt;Redis缓存更新策略&lt;/h4&gt;
&lt;h4 id=&#34;cache-aside-pattern&#34;&gt;Cache Aside Pattern&lt;/h4&gt;
&lt;p&gt;这是最常用最常用的pattern了。其具体逻辑如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;失效&lt;/strong&gt;：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命中&lt;/strong&gt;：应用程序从cache中取数据，取到后返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：先把数据存到数据库中，成功后，再让缓存失效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1)在更新数据时，我们可以不更新缓存，而是删除缓存中的数据，&lt;/p&gt;
&lt;p&gt;2)在读取数据时，发现缓存中没有，再从数据库中读取数据，更新到缓存中。&lt;/p&gt;
&lt;p&gt;这就是 &lt;strong&gt;Cache Aside 策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写时可不可以先删除缓存？不行！&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;A 先删了缓存，还没等数据库更新完成呢，就被 B 把缓存更新为了旧值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cache Aside 策略也是&lt;strong&gt;不保证数据一致性&lt;/strong&gt;的，它的作用是大大减少不一致性。&lt;/p&gt;
&lt;p&gt;某些极端情况还是存在不一致，如果业务上不允许，可以考虑加分布式锁。&lt;/p&gt;
&lt;p&gt;一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。&lt;/p&gt;
&lt;p&gt;这是标准的design pattern，包括Facebook的论文《&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf&#34;&gt;Scaling Memcache at Facebook&lt;/a&gt;》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《&lt;a href=&#34;https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend&#34;&gt;Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?&lt;/a&gt;》，主要是怕两个并发的写操作导致脏数据。&lt;/p&gt;
&lt;p&gt;那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。&lt;/p&gt;
&lt;p&gt;但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而&lt;strong&gt;读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/17416.html&#34;&gt;缓存更新的套路&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;中间件&#34;&gt;中间件&lt;/h2&gt;
&lt;h3 id=&#34;rocketmq&#34;&gt;rocketmq&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/interview-linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/interview-linux/</guid>
      
        <description>&lt;h1 id=&#34;linux-命令-运维-devops&#34;&gt;Linux 命令 运维 devops&lt;/h1&gt;
&lt;h3 id=&#34;linux查看当前登录用户&#34;&gt;linux查看当前登录用户&lt;/h3&gt;
&lt;p&gt;1，w,显示目前登入系统的用户信息&lt;/p&gt;
&lt;p&gt;-f 　开启或关闭显示用户从何处登入系统。&lt;/p&gt;
&lt;p&gt;-h 　不显示各栏位的标题信息列。&lt;/p&gt;
&lt;p&gt;-l 　使用详细格式列表，此为预设值。&lt;/p&gt;
&lt;p&gt;-s 　使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。&lt;/p&gt;
&lt;p&gt;-u 　忽略执行程序的名称，以及该程序耗费CPU时间的信息。&lt;/p&gt;
&lt;p&gt;-V 　显示版本信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@card-web03 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# w&lt;/span&gt;
 17:28:45 up &lt;span style=&#34;color:#ae81ff&#34;&gt;84&lt;/span&gt; days, 23:32,  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; user,  load average: 0.01, 0.03, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/1    123.115.76.110   17:06    5.00s  0.03s  0.00s w

输出的结果的含义：

USER 登录的用户名

TTY 登录终端

FROM 从哪个IP地址登录

LOGIN@ 登录时间

IDLE 用户闲置时间

JCPU 指的是和该终端连接的所有进程占用的时间，这个时间里并不包括过去的后台

作业时间，但却包括当前正在运行的后台作业所占用的时间

PCPU 当前进程所占用的时间

WHAT 当前正在运行的命令
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.who&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;显示当前已登录的用户信息
输出的结果有：用户名，登录终端，登录的时间
[root@card-web03 ~]# who
root     pts/1        2019-03-12 17:06 (12.3.1.15)
 
#输出的结果有：用户名，登录终端，登录的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.last&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;列出目前与过去登入系统的用户相关信息。
- R: 省略 hostname 的栏位
－n：指定输出记录的条数。
－f file：指定用文件file作为查询用的log文件。
－t tty：只显示指定的虚拟控制台上登录情况。
－h 节点：只显示指定的节点上的登录情况。
－i IP：只显示指定的IP上登录的情况。
－1：用IP来显示远端地址。
－y：显示记录的年、月、日。     
－ID：知道查询的用户名。
－x:显示系统关闭、用户登录和退出的历史。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@card-web03 ~]# last
root     pts/1        12.3.11.5   Tue Mar 12 17:06   still logged in   
root     pts/1        12.3.11.5   Tue Mar 12 16:03 - 16:06  (00:02)    
root     pts/2        12.3.11.5   Tue Mar 12 15:46 - 15:46  (00:00)    
root     pts/2        12.3.11.5   Tue Mar 12 15:44 - 15:44  (00:00)    
root     pts/3        12.3.11.5   Tue Mar 12 15:42 - 15:42  (00:00)    
root     pts/2        12.3.11.5   Tue Mar 12 15:41 - 15:42  (00:01) 
 
#命令的输出包含：用户名，登录终端，登录IP，登录时间，退出时间（在线时间）
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;vmstat&#34;&gt;vmstat&lt;/h3&gt;
&lt;p&gt;vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。&lt;/p&gt;
&lt;p&gt;一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;root@ubuntu:~# vmstat &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3498472&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;315836&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3819540&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2表示每个两秒采集一次服务器状态，1表示只采集一次。&lt;/p&gt;
&lt;p&gt;实际上，在应用过程中，我们会在一段时间内一直监控，不想监控直接结束vmstat就行了,例如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;root@ubuntu:~# vmstat &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs    us sy id wa
 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3499840&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;315836&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3819660&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3499584&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;315836&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3819660&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;88&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;158&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3499708&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;315836&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3819660&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;86&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;162&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3499708&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;315836&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3819660&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;81&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;151&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3499732&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;315836&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3819660&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;83&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;154&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这表示vmstat每2秒采集数据，一直采集，直到我结束程序，这里采集了5次数据我就结束了程序。&lt;/p&gt;
&lt;p&gt;好了，命令介绍完毕，现在开始实战讲解每个参数的意思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;r&lt;/strong&gt; 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b&lt;/strong&gt; 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;swpd&lt;/strong&gt; 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;free&lt;/strong&gt;  空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;buff&lt;/strong&gt;  Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cache&lt;/strong&gt; cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;si&lt;/strong&gt; 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;so&lt;/strong&gt; 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bi&lt;/strong&gt; 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bo&lt;/strong&gt; 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt; 每秒CPU的中断次数，包括时间中断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cs&lt;/strong&gt; 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;us&lt;/strong&gt; 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sy&lt;/strong&gt; 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;id&lt;/strong&gt; 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wt&lt;/strong&gt; 等待IO CPU时间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html&#34;&gt;https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A0%94%E7%A9%B6/</guid>
      
        <description>&lt;h1 id=&#34;中间件问题研究&#34;&gt;中间件问题研究&lt;/h1&gt;
&lt;h3 id=&#34;exactly-once投递语义&#34;&gt;Exactly-Once投递语义&lt;/h3&gt;
&lt;p&gt;​        本文主要介绍消息队列RocketMQ版的Exactly-Once投递语义的概念和典型使用场景，以便您理解如何使得消息只被消费端处理且仅处理一次。&lt;/p&gt;
&lt;h4 id=&#34;什么是exactly-once投递语义&#34;&gt;什么是Exactly-Once投递语义&lt;/h4&gt;
&lt;p&gt;​        Exactly-Once是指发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。&lt;/p&gt;
&lt;p&gt;Exactly-Once语义是消息系统和流式计算系统中消息流转的最理想状态，但是在业界并没有太多理想的实现。因为真正意义上的Exactly-Once依赖消息系统的服务端、消息系统的客户端和用户消费逻辑这三者状态的协调。例如，当您的消费端完成一条消息的消费处理后出现异常宕机，而消费端重启后由于消费的位点没有同步到消息系统的服务端，该消息有可能被重复消费。&lt;/p&gt;
&lt;p&gt;业界对于Exactly-Once投递语义存在很大的争议，很多人会拿出“FLP不可能理论”或者其他一致性定律对此议题进行否定，但事实上，特定场景的Exactly-Once语义实现并不是非常复杂，只是因为通常大家没有精确的描述问题的本质。&lt;/p&gt;
&lt;p&gt;如果您要实现一条消息的消费结果只能在业务系统中生效一次，您需要解决的只是如何保证同一条消息的消费幂等问题。消息队列RocketMQ版的Exactly-Once语义就是解决业务中最常见的一条消息的消费结果（消息在消费端计算处理的结果）在数据库系统中有且仅生效一次的问题。&lt;/p&gt;
&lt;h4 id=&#34;典型使用场景&#34;&gt;典型使用场景&lt;/h4&gt;
&lt;p&gt;在电商系统中，上游实时计算模块发布商品价格变更的信息，异步通知到下游商品管理模块进行价格变更。此时，需要保证每一条信息的消费幂等，即重复的价格变更信息只会生效一次，这样便不会发生价格多次重复修改的情况，确保实现了消息消费的幂等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cspringcloud%5Cp69179.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mq&#34;&gt;MQ&lt;/h3&gt;
&lt;h4 id=&#34;去重&#34;&gt;去重&lt;/h4&gt;
&lt;p&gt;要去重，先要识别重复消息。通常的做法是在生产消息时，业务方在消息体中插入去重 key，消费时通过该去重 key 来识别重复消息。去重 key 可以是由 &amp;lt;生产者 IP + 线程 ID + 时间戳 + 时间内递增值&amp;gt; 组成的唯一值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免重复提交：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景：A 为生产者，B 为消费者，中间是 CMQ。A 已完成10元转账操作，且将消息发送给 CMQ，CMQ 也已成功收到。此时网络闪断或者客户端 A 宕机导致服务端应答给客户端 A 失败。A 会认为发送失败，从而再次生产消息。这会造成重复提交。&lt;/li&gt;
&lt;li&gt;解决方法：A 在生产消息时，加入 time 时间戳等信息，生成唯一的去重 key。若生产者 A 由于网络问题判断当前发送失败，重试时，去重 key 沿用第一次发送的去重 key。此时消费者 B 可通过去重 key 判断并做去重。
该案例也说明了不能使用 CMQ 的 Message ID 进行去重，因为这两条消息有不同的 ID，但却有相同的 body。&lt;/li&gt;
&lt;li&gt;注意事项：生产者A，在发送消息之前，要将去重 key 做持久化（写磁盘等，避免掉电后丢失）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;避免多条相同 body 的消息被过滤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景：A 给 B 转账10元，一共发起5次，每一次提交的 body 内容是一样的。如果消费者粗暴用 body 做去重判断，就会把5次请求，当做1次请求来处理。&lt;/li&gt;
&lt;li&gt;解决方法：A 在生产消息时，加入 time 时间戳等信息。此时哪怕消息 body 一样，生成的去重 key 都是不同的，这样就满足了多次发送同样内容的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;微众银行的金融级消息服务平台建设实践和思考&#34;&gt;微众银行的金融级消息服务平台建设实践和思考&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;消息去重&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在负载均衡的一个很短时间内，当新上一个实例的时候，由于大家分到的Q都是相同的，当前一个分到Q的还在继续拉消息，下一个实例由于负载均衡很快做完，也分到Q，就会去拿这个Q的消息，这个时候就会出现消息的重复。此时，通常会通过Redis等缓存方式进行去重，也可以在Broker上做一个简单的处理，例如用互斥锁，在竞争消费的短时间内，对其进行加锁，抢到锁的才能进行消费，同时占有锁的时间有限制，从而解决消息去重的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43332570/article/details/107725522&#34;&gt;RabbitMQ中使用Redis解决消费者重复消费的问题&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; com.wcong.utils&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.beans.factory.annotation.Autowired&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.data.redis.core.RedisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.stereotype.Component&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @author wcong
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @version 1.0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @date 2020-07-31 8:11
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@Component&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RedisCacheUtil&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Autowired&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; RedisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Object&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 写入缓存
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param val
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setKey&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String key&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Object val&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;val&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Exception e&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
            e&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 写入缓存，可以设置过期时间
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param val
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setKey&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String key&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Object val&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Long time&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;val&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;time&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Exception e&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
            e&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 判断key是否存在
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exists&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String key&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hasKey&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Exception e&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
            e&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 读取缓存
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Object &lt;span style=&#34;color:#a6e22e&#34;&gt;getVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String key&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;opsForValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 删除缓存
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String key&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;delete&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 批量删除缓存
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param keys
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt; keys&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String key &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; keys&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;delete&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;————————————————&lt;/span&gt;
版权声明&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;本文为CSDN博主&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;「&lt;/span&gt;夕灬颜&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;」&lt;/span&gt;的原创文章&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;遵循CC 4&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;0&lt;/span&gt; BY&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;SA版权协议&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;转载请附上原文出处链接及本声明&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
原文链接&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;https&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//blog.csdn.net/qq_43332570/article/details/107725522
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;设置redis的序列化方式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; com.wcong.config&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.context.annotation.Bean&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.context.annotation.Configuration&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.context.annotation.Primary&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.data.redis.connection.RedisConnectionFactory&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.data.redis.core.RedisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; org.springframework.data.redis.serializer.StringRedisSerializer&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @author wcong
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @version 1.0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @date 2020-07-31 8:18
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RedisConfig&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 设置redis的序列化方式
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Bean&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Primary&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; RedisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Object&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;redisTemplate&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;RedisConnectionFactory redisConnectionFactory&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        RedisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;Object&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; redisTemplate &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; RedisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setConnectionFactory&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;redisConnectionFactory&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setKeySerializer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringRedisSerializer&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
        redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setHashKeySerializer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringRedisSerializer&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
        redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setValueSerializer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; GenericJackson2JsonRedisSerializer&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
        redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setHashValueSerializer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; GenericJackson2JsonRedisSerializer&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; redisTemplate&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-mysql/</guid>
      
        <description>&lt;h1 id=&#34;mysql性能调优&#34;&gt;mysql性能调优&lt;/h1&gt;
&lt;h3 id=&#34;读写分离&#34;&gt;读写分离&lt;/h3&gt;
&lt;p&gt;1）既然是读写分离，那肯定有读库和写库，datasource配置主库master，slave&lt;/p&gt;
&lt;p&gt;2）路由，根据规则路由到主库or从库。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;主库的职能是负责写,从库主要是负责读,可以建立读库集群,通过读写职能在数据源上的隔离达到减少读写冲突、 释压数据库负载、保护数据库的目的。
https://cloud.tencent.com/developer/article/1769947
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/baomidou/dynamic-datasource-spring-boot-starter
一个基于springboot的快速集成多数据源的启动器
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;分表分库
https://blog.fleyx.com/blog/detail/2019-03-20-10-38/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体springboot是如何做的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一: 主从数据源的配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二: 数据源路由的配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三：数据源上下文环境&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务器硬件的优化&#34;&gt;服务器硬件的优化&lt;/h2&gt;
&lt;p&gt;提升硬件设备，例如选择尽量高频率的内存（频率不能高于主板的支持）、提升网络带宽、使用SSD高速磁盘、提升CPU性能等。&lt;/p&gt;
&lt;p&gt;CPU的选择: CPU的频率和数量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据库并发比较高的场景，CPU的数量比频率重要。&lt;/li&gt;
&lt;li&gt;对于CPU密集型场景和频繁执行复杂SQL的场景，CPU的频率越高越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql数据库配置优化&#34;&gt;MySQL数据库配置优化&lt;/h2&gt;
&lt;p&gt;表示缓冲池字节大小。
推荐值为物理内存的50%~80%。
innodb_buffer_pool_size&lt;/p&gt;
&lt;p&gt;用来控制redo log刷新到磁盘的策略。 innodb_flush_log_at_trx_commit=1&lt;/p&gt;
&lt;p&gt;每提交1次事务同步写到磁盘中，可以设置为n。 sync_binlog=1&lt;/p&gt;
&lt;p&gt;脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘。 推荐值为25%~50%。 innodb_max_dirty_pages_pct=30&lt;/p&gt;
&lt;p&gt;后台进程最大IO性能指标。
默认200，如果SSD，调整为5000~20000
innodb_io_capacity=200&lt;/p&gt;
&lt;p&gt;指定innodb共享表空间文件的大小。 innodb_data_file_path&lt;/p&gt;
&lt;p&gt;慢查询日志的阈值设置，单位秒。 long_qurey_time=0.3&lt;/p&gt;
&lt;p&gt;mysql复制的形式，row为MySQL8.0的默认形式。 binlog_format=row&lt;/p&gt;
&lt;p&gt;调高该参数则应降低interactive_timeout、wait_timeout的值。 max_connections=200&lt;/p&gt;
&lt;p&gt;过大，实例恢复时间长；过小，造成日志切换频繁。 innodb_log_file_size&lt;/p&gt;
&lt;p&gt;全量日志建议关闭。
默认关闭。
general_log=0&lt;/p&gt;
&lt;h2 id=&#34;mysql表结构与sql优化&#34;&gt;MySQL表结构与SQL优化&lt;/h2&gt;
&lt;h3 id=&#34;索引分类&#34;&gt;索引分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;全文索引(FULLTEXT)&lt;/code&gt;：全文索引，&lt;del&gt;目前只有 MyISAM 引擎支持全局索引&lt;/del&gt;，它的出现是为了解决针对文本的模糊查询效率较低的问题，并且只限于 CHAR、VARCHAR 和 TEXT 列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;哈希索引(HASH)&lt;/code&gt;：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B-Tree 索引&lt;/code&gt;：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R-Tree 索引&lt;/code&gt;：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从逻辑上来对 MySQL 进行分类，主要分为下面这几种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;普通索引：普通索引是最基础的索引类型，它没有任何限制 。创建方式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; normal_index &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; cxuan003(id);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;删除方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;drop&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; normal_index &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; cxuan003;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;唯一索引：唯一索引列的值必须唯一，允许有空值，如果是组合索引，则列值的组合必须唯一，创建方式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unique&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; normal_index &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; cxuan003(id);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键索引：是一种特殊的索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
         &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; int(&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; AUTO_INCREMENT ,
         &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;title&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; char(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; ,
         &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则，下面我们就会创建组合索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较，目前只有 char、varchar，text 列上可以创建全文索引，创建表的适合添加全文索引&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (
    &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; int(&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; AUTO_INCREMENT ,
    &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;title&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; char(&lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;) CHARACTER &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; ,
    &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;content&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; text CHARACTER &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; ,
    &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;time&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; int(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; ,
    &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;),
    FULLTEXT (content)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然也可以直接创建全文索引&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; FULLTEXT &lt;span style=&#34;color:#66d9ef&#34;&gt;INDEX&lt;/span&gt; index_content &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; article(content)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;索引优化规则&#34;&gt;索引优化规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用最左前缀规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用联合索引，要遵守最左前缀规则。即要求使用联合索引进行查询，从索引的最左前列开始，不跳过索引中的列并且不能使用范围查询(&amp;gt;、&amp;lt;、between、like)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模糊查询不能利用索引(like &amp;lsquo;%XX&amp;rsquo;或者like &amp;lsquo;%XX%&#39;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如索引列code的值为&amp;rsquo;AAA&amp;rsquo;,&amp;lsquo;AAB&amp;rsquo;,&amp;lsquo;BAA&amp;rsquo;,&amp;lsquo;BAB&amp;rsquo;，如果where code like &amp;lsquo;%AB&amp;rsquo;条件，由于条件前面是模糊的，所以不能利用索引的顺序，必须逐个查找，看是否满足条件。这样会导致全索引扫描或者全表扫描。&lt;/p&gt;
&lt;p&gt;如果是where code like &amp;lsquo;A%&#39;，就可以查找code中A开头的数据，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求，这样可以提高查询效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要过多创建索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;过多的索引会占用更多的空间，而且每次增、删、改操作都会重建索引。&lt;/p&gt;
&lt;p&gt;在一般的互联网场景中，查询语句的执行次数远远大于增删改语句的执行次数，所以重建索引的开销可以忽略不计。但在大数据量导入时，可以考虑先删除索引，批量插入数据，然后添加索引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量扩展索引，比如现有索引(a)，现在又要对(a,b)进行索引，那么只需要修改索引(a)即可，避免不必要的索引冗余。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;索引长度尽量短&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;短索引可以节省索引空间，使查找的速度得到提升，同时内存中也可以装载更多的索引键值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;太长的列，可以选择建立前缀索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;索引更新不能频繁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更新非常频繁的数据不适宜建索引，因为维护索引的成本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引列不能参与计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要在索引列上做任何的操作，包括计算、函数、自动或者手动类型的转换，这样都会导致索引失效。&lt;/p&gt;
&lt;p&gt;比如，where from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成where create_time = unix_timestamp(’2014-05-29’)。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;h3 id=&#34;查询时的优化&#34;&gt;查询时的优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小表驱动大表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免全表扫描&lt;/p&gt;
&lt;p&gt;mysql在使用不等于(!=或者&amp;lt;&amp;gt;)的时候索引无法使用导致全表扫描。在查询的时候，如果对索引使用不等于的操作将会导致索引失效，进行全表扫描&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用覆盖索引，少使用select*&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要用到什么数据就查询什么数据，这样可以减少网络的传输和mysql的全表扫描。&lt;/p&gt;
&lt;p&gt;尽量使用覆盖索引，比如索引为name，age，address的组合索引，那么尽量覆盖这三个字段之中的值，mysql将会直接在索引上取值（using index），并且返回值不包含不是索引的字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order by的索引生效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;order by排序应该遵循最佳左前缀查询，如果是使用多个索引字段进行排序，那么排序的规则必须相同（同是升序或者降序），否则索引同样会失效。&lt;/p&gt;
&lt;h3 id=&#34;其他优化&#34;&gt;其他优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开启慢查询&lt;/p&gt;
&lt;p&gt;开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，更好的优化数据库系统的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时获取有性能问题的SQL&lt;/p&gt;
&lt;p&gt;例如下面的SQL的作用是查看正在执行的线程，并按Time倒排序，查看执行时间过长的线程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; information_schema.processlist &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; Command &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Sleep&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;order&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;by&lt;/span&gt; Time &lt;span style=&#34;color:#66d9ef&#34;&gt;desc&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直分割&lt;/p&gt;
&lt;p&gt;“垂直分割”是一种把数据库中的表，按列变成几张表的方法。这样可以降低表的复杂度和字段的数目，从而达到优化的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;示例一：

在Users表中有一个字段是address，它是可选字段，并且不需要经常读取或是修改。

那么，就可以把它放到另外一张表中，这样会让原表有更好的性能。

示例二：

有一个叫 “last_login”的字段，它会在每次用户登录时被更新，每次更新时会导致该表的查询缓存被清空。

所以，可以把这个字段放到另一个表中。

这样就不会影响对用户ID、用户名、用户角色(假设这几个属性并不频繁修改)的不停地读取了，因为查询缓存会增加很多性能。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作者：Sufho
链接：https://juejin.cn/post/6844904114250334215
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-spring/</guid>
      
        <description>&lt;h1 id=&#34;面试准备-spring&#34;&gt;面试准备 Spring&lt;/h1&gt;
&lt;h4 id=&#34;springcloud多项目共享依赖工具类以及依赖版本管理&#34;&gt;SpringCloud多项目共享依赖、工具类以及依赖版本管理&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/860277630/SpringCloud-demo/tree/master/yingxue_parent&#34;&gt;[SpringCloud-demo]&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;!-- spring-cloud --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;为什么说feign是伪rpc&#34;&gt;为什么说Feign是伪RPC？&lt;/h4&gt;
&lt;p&gt;无非也就是Spring是基于Http协议的RPC，有人就认为不是RPC调用&lt;/p&gt;
&lt;p&gt;其实判断RPC尽可以不那么复杂，你像调本地接口一样调用远程接口的方式，就是RPC。&lt;/p&gt;
&lt;p&gt;如果你想知道的明确一点，看这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Cspringcloud%5Crpc.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;虚线的框里是你不用去实现，RPC框架已经帮你做了。&lt;/p&gt;
&lt;p&gt;实际上RPC也就是一种编程模型，初衷就是你可以不在乎底层的网络技术协议而实现远程调用&lt;/p&gt;
&lt;p&gt;无论基于Http协议还是基于TCP协议都不影响他是RPC框架&lt;/p&gt;
&lt;p&gt;接下来解释Feign：&amp;ndash;&amp;gt; 我们都知道，Feign封装了Ribbon和Hystrix也就是客户端负载均衡以及服务容错保护。&amp;ndash;&amp;gt; Ribbon里面有个啥？RestTemplate&amp;ndash;&amp;gt; RestTemplate是个啥？封装了Http请求，实现了客户端负载均衡&amp;ndash;&amp;gt; 最后Feign做了啥？简化了我们自行封装RestTemplate服务调用客户端的开发量&lt;/p&gt;
&lt;p&gt;这就是Feign，所以说**“Feign是伪RPC”这个说法本身就有点问题**，Feign是一个工具，基于Netflix Feign来实现，它简化了我们对于Ribbon和Hystrix的自主代码实现，就这样。&lt;/p&gt;
&lt;p&gt;你说这Feign跟RPC啥关系？算是个实现RPC调用的工具？大概如此。。。&lt;/p&gt;
&lt;p&gt;还有很多关于SpringCloud和Dubbo的比较，我觉得实际上也没太大意义，根据实际业务需求来选择合适的即可&lt;/p&gt;
&lt;h4 id=&#34;spring-cloud-gateway实现灰度发布功能&#34;&gt;Spring Cloud Gateway实现灰度发布功能&lt;/h4&gt;
&lt;p&gt;1、首先编写自己的Predicate，实现指定用户匹配到指定的路由规则中；&lt;/p&gt;
&lt;p&gt;2、动态修改请求，添加版本号信息，版本号信息可以放在HTTP Header中（此处可以通过原生&lt;code&gt;AddRequestHeaderGatewayFilterFactory&lt;/code&gt;来实现，无需自己写代码）；&lt;/p&gt;
&lt;p&gt;3、重写负载均衡算法，根据版本号信息从注册中心的服务实例上选择相应的服务版本进行请求的转发。&lt;/p&gt;
&lt;p&gt;作者：公众号WU双
链接：https://www.jianshu.com/p/6db15bc0be8f
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</guid>
      
        <description>&lt;h2 id=&#34;面试准备一-2022-2-12&#34;&gt;面试准备(一) 2022 2 12&lt;/h2&gt;
&lt;h3 id=&#34;一技术&#34;&gt;一、技术&lt;/h3&gt;
&lt;h3 id=&#34;oauth2&#34;&gt;oauth2&lt;/h3&gt;
&lt;p&gt;什么是oauth2?&lt;/p&gt;
&lt;p&gt;答：是一种授权机制，颁发令牌（token），用来授权第三方应用，获取用户数据。&lt;/p&gt;
&lt;h4 id=&#34;rfc-6749&#34;&gt;RFC 6749&lt;/h4&gt;
&lt;blockquote&gt;
&lt;h6 id=&#34;oauth-引入了一个授权层用来分离两种不同的角色客户端和资源所有者资源所有者同意以后资源服务器可以向客户端颁发令牌客户端通过令牌去请求数据&#34;&gt;OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。&amp;hellip;&amp;hellip;资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。&lt;/h6&gt;
&lt;/blockquote&gt;
&lt;p&gt;**OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。**下面就是这四种授权方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;授权码（authorization-code）&lt;/li&gt;
&lt;li&gt;隐藏式（implicit）&lt;/li&gt;
&lt;li&gt;密码式（password）：&lt;/li&gt;
&lt;li&gt;客户端凭证（client credentials）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。&lt;/p&gt;
&lt;h2 id=&#34;授权码&#34;&gt;授权码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;https://b.com/oauth/authorize?
  response_type=code&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;
  client_id=CLIENT_ID&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;
  redirect_uri=CALLBACK_URL&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;
  scope=read
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面 URL 中，&lt;code&gt;response_type&lt;/code&gt;参数表示要求返回授权码（&lt;code&gt;code&lt;/code&gt;），&lt;code&gt;client_id&lt;/code&gt;参数让 B 知道是谁在请求，&lt;code&gt;redirect_uri&lt;/code&gt;参数是 B 接受或拒绝请求后的跳转网址，&lt;code&gt;scope&lt;/code&gt;参数表示要求的授权范围（这里是只读）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回&lt;code&gt;redirect_uri&lt;/code&gt;参数指定的网址。跳转时，会传回一个授权码，就像下面这样。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;https://a.com/callback?code=AUTHORIZATION_CODE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面 URL 中，&lt;code&gt;code&lt;/code&gt;参数就是授权码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://b.com/oauth/token?
 client_id=CLIENT_ID&amp;amp;
 client_secret=CLIENT_SECRET&amp;amp;
 grant_type=authorization_code&amp;amp;
 code=AUTHORIZATION_CODE&amp;amp;
 redirect_uri=CALLBACK_URL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 URL 中，&lt;code&gt;client_id&lt;/code&gt;参数和&lt;code&gt;client_secret&lt;/code&gt;参数用来让 B 确认 A 的身份（&lt;code&gt;client_secret&lt;/code&gt;参数是保密的，因此只能在后端发请求），&lt;code&gt;grant_type&lt;/code&gt;参数的值是&lt;code&gt;AUTHORIZATION_CODE&lt;/code&gt;，表示采用的授权方式是授权码，&lt;code&gt;code&lt;/code&gt;参数是上一步拿到的授权码，&lt;code&gt;redirect_uri&lt;/code&gt;参数是令牌颁发后的回调网址。&lt;/p&gt;
&lt;p&gt;第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向&lt;code&gt;redirect_uri&lt;/code&gt;指定的网址，发送一段 JSON 数据。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{    
  &amp;quot;access_token&amp;quot;:&amp;quot;ACCESS_TOKEN&amp;quot;,
  &amp;quot;token_type&amp;quot;:&amp;quot;bearer&amp;quot;,
  &amp;quot;expires_in&amp;quot;:2592000,
  &amp;quot;refresh_token&amp;quot;:&amp;quot;REFRESH_TOKEN&amp;quot;,
  &amp;quot;scope&amp;quot;:&amp;quot;read&amp;quot;,
  &amp;quot;uid&amp;quot;:100101,
  &amp;quot;info&amp;quot;:{...}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 JSON 数据中，&lt;code&gt;access_token&lt;/code&gt;字段就是令牌，A 网站在后端拿到了。&lt;/p&gt;
&lt;h3 id=&#34;docker-gitlabjenkins-cicd&#34;&gt;docker +gitlab+Jenkins ci/cd&lt;/h3&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;需求的变化，服务的数量，快速，智能。-&amp;gt; ci/cd&lt;/p&gt;
&lt;p&gt;随着业务的增长，需求也开始增多，每个需求的大小，开发周期，发布时间都不一致。基于微服务的系统架构，功能的叠加，对应的服务的数量也在增加，大小功能的快速迭代，更加要求部署的快速化，智能化。因此，传统的人工部署已经心有余而力不足。
持续集成，持续部署，持续交互对于微服务开发来说，是提高团队整体效率不可或缺的一环。合理的使用CI,CD能够极大的提高了生产效率，也提高了产品的交互质量。本文不对三个概念做过多的介绍，有兴趣可以读读这篇文章：&lt;a href=&#34;https://link.jianshu.com/?t=http://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/&#34;&gt;The Product Managers’ Guide to Continuous Delivery and DevOps&lt;/a&gt; 我想会有一定的收获。
本文主要介绍下基于Jenkins+docker 实现自动化部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cbobstone%5CPictures%5Ccicd%5C0.4404789561377548.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dockerjenkins&#34;&gt;docker+Jenkins&lt;/h4&gt;
&lt;p&gt;1）jdk git 默认是有的，maven需要挂载宿主机&lt;/p&gt;
&lt;p&gt;​      因为用到的docker镜像中不包含maven，所以要在宿主机中安装，通过文件挂载的方式提供调用&lt;/p&gt;
&lt;p&gt;2）时钟同步&lt;/p&gt;
&lt;p&gt;3）密钥的问题&lt;/p&gt;
&lt;h4 id=&#34;使用ssh方法拉取重点&#34;&gt;使用ssh方法拉取（重点）&lt;/h4&gt;
&lt;p&gt;使用ssh的方法拉取的话先在本地生成公钥和私钥，注意，公钥（id_rsa.pub）保存到gitlab中，   私钥（id_rsa）保存到jenkins中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这里要强调一点，有些同学刚开不知道这个公钥和私钥要建在那个服务器上，这个很简单，就是你想在那台服务器上从gitlab中拉取代码，那么你就建在那个服务器上，而我这里是使用Jenkins从gitlab拉取代码，而jenkins又是以docker容器的方式运行的，那么我就在jenkins这个容器中来产生秘钥。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;h4 id=&#34;gitlab&#34;&gt;gitlab&lt;/h4&gt;
&lt;h5 id=&#34;heading-1&#34;&gt;&lt;/h5&gt;
&lt;h5 id=&#34;1端口映射&#34;&gt;1、端口映射&lt;/h5&gt;
&lt;p&gt;这里的坑在于，我们的gitlab是运行在容器中的，通过gitlab的web服务，我们获取到的clone地址，是没有考虑过宿主机与容器之间的端口映射的，所以我们在启动容器时，需要把映射使用的端口考虑进去，最理想的是宿主机端口与容器端口完全对应。所以使用docker部署gitlab，http 端口 设置成一样 例如：80：80 8929:8929&lt;/p&gt;
&lt;p&gt;The port specified in this URL must match the port published to the host by Docker. Additionally, if the NGINX listen port is not explicitly set in &lt;code&gt;nginx[&#39;listen_port&#39;]&lt;/code&gt;, it will be pulled from the &lt;code&gt;external_url&lt;/code&gt;. For more information see the &lt;a href=&#34;https://docs.gitlab.com/omnibus/settings/nginx.html&#34;&gt;NGINX documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;此URL中指定的端口必须与Docker发布到主机的端口匹配。此外，如果NGINX[&amp;lsquo;listen_port&amp;rsquo;]中没有显式设置NGINX listen端口，则它将从external_url中提取。有关更多信息，请参阅NGINX文档。&lt;/p&gt;
&lt;h4 id=&#34;dockerfile-中-run-cmd-entrypoint-的区别&#34;&gt;Dockerfile 中 RUN, CMD, ENTRYPOINT 的区别&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;RUN 指令：用于指定 docker build 过程中要运行的命令。
//docker build 命令用于使用 Dockerfile 创建镜像。
	语法格式：
	 RUN &amp;lt;command&amp;gt; 或
	 RUN &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;executeable&amp;gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;param1&amp;gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;param2&amp;#34;&lt;/span&gt;,...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
	 RUN &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/bin/bash&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;executeable&amp;gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;param1&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;param2&amp;#34;&lt;/span&gt;,...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
			
	例如：
		RUN yum install iproute nginx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yum clean all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CMD 指令：类似于 RUN 指令，用于运行程序，但二者运行的时间点不同；CMD 在docker run 时运行，而非docker build;
//docker run ：创建一个新的容器并运行一个命令

CMD 指令的首要目的在于为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束；注意: CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。
	语法格式：
	CMD &amp;lt;command&amp;gt; 或
	CMD [&amp;quot;&amp;lt;executeable&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...] 
	CMD [&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...] 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数；
注意：如果 dockerfile 中如果存在多个CMD指令，仅最后一个生效；
		
	例如：		
            CMD [&amp;quot;/usr/sbin/httpd&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;/etc/httpd/conf/httpd.conf&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ENTRYPOINT 指令：类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序；但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序；
    语法格式：
	ENTRYPOINT &amp;lt;command&amp;gt; 或
	ENTRYPOINT [&amp;quot;&amp;lt;executeable&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...]
			
	例如：
	    CMD [&amp;quot;-c&amp;quot;]
	    ENTRYPOINT [&amp;quot;top&amp;quot;,&amp;quot;-b&amp;quot;]
eg:
docker run -it --entrypoint=/bin/bash nginx
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ENTRYPOINT 与 CMD 区别

如：
FROM ubuntu:14.10  
ENTRYPOINT [&amp;quot;top&amp;quot;, &amp;quot;-b&amp;quot;]   
CMD [&amp;quot;-c&amp;quot;]  
	
把可能需要变动的参数写到 CMD 里面。然后你可以在 docker run 里指定参数，这样 CMD 里的参数(这里是-c) 就会被覆盖掉而 ENTRYPOINT 里的不被覆盖。

注意：
ENTRYPOINT有两种写法，第二种(shell form)会屏蔽掉 docker run 时后面加的命令和 CMD 里的参数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把不变的写到entrypoint中，可能变化的参数可以写到CMD里面&lt;/p&gt;
&lt;h3 id=&#34;springboot源码&#34;&gt;springboot源码&lt;/h3&gt;
&lt;h4 id=&#34;springboot-项目启动分析&#34;&gt;springboot 项目启动分析&lt;/h4&gt;
&lt;p&gt;1）main方法启动的。&lt;/p&gt;
&lt;p&gt;2）复合注解 @SpringBootApplication&lt;/p&gt;
&lt;p&gt;3）@EnableAutoConfiguration&lt;/p&gt;
&lt;p&gt;4）@Import&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Import&lt;/span&gt;(AutoConfigurationImportSelector.&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;AutoConfigurationImportSelector 类的 selectImports() 方法里面通过调用Spring Core 包里 SpringFactoriesLoader 类的 loadFactoryNames()方法

最终通过 SpringFactoriesLoader.loadFactoryNames() 读取了 ClassPath 下面的 **META-INF/spring.factories** 文件来获取所有导出类。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;而spring.factories 文件里关于 EnableAutoConfiguration 的配置其实就是一个键值对结构，样子大概长下面这样：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/9824247-2efacf54f0fa651e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;说了这么多，如果从稍微宏观一点的角度 &lt;strong&gt;概括总结&lt;/strong&gt; 上述这一过程那就是：&lt;/p&gt;
&lt;p&gt;从 ClassPath下扫描所有的 META-INF/spring.factories 配置文件，并将spring.factories 文件中的 EnableAutoConfiguration 对应的配置项通过反射机制实例化为对应标注了 @Configuration 的形式的IoC容器配置类，然后注入IoC容器。&lt;/p&gt;
&lt;p&gt;作者：CodeSheep
链接：https://www.jianshu.com/p/9dc7a385d19e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B8%89dubbo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B8%89dubbo/</guid>
      
        <description>&lt;h1 id=&#34;面试准备三-dubbo&#34;&gt;面试准备（三） Dubbo&lt;/h1&gt;
&lt;h3 id=&#34;dubbo-spi&#34;&gt;Dubbo SPI&lt;/h3&gt;
&lt;p&gt;spi是一种插件机制&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。
这样可以在运行时，动态为接口替换实现类。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dubbo 中，SPI 主要有两种用法，一种是加载固定的扩展类，另一种是加载自适应扩展类。这两种方式会在下面详细的介绍。 需要特别注意的是: &lt;strong&gt;在 Dubbo 中，基于 SPI 扩展加载的类是单例的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;加载自适应扩展类&#34;&gt;加载自适应扩展类&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;https://dubbo.apache.org/zh/docs/references/spis/dubbo-spi/&#34;&gt;本文介绍了 Dubbo SPI 的原理和实现细节&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;系统设计微服务重试机制&#34;&gt;系统设计｜微服务重试机制&lt;/h3&gt;
&lt;h4 id=&#34;为什么微服务重试机制很重要&#34;&gt;为什么微服务重试机制很重要？&lt;/h4&gt;
&lt;p&gt;当我们单体应用时，所有的逻辑计算都在单一的进程中，除了进程断电外几乎不可能有处理失败的情况。然而，当我们把单体应用拆分为一个个细分的子服务后，服务间的互相调用无论是RPC还是HTTP，都是依赖于网络。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;网络是脆弱的&lt;/strong&gt;，不时请求会出现抖动失败。例如我们的 Server1 调用 Server2 进行下单时，可能网络超时了，这个时候 Server1 就需要返回给用户提示「网络错误」，这样我们的服务质量就下降了，可能会收到用户的投诉吐槽，降低产品竞争力。&lt;/p&gt;
&lt;p&gt;这也是为什么很多产品内部都建设接口维度的 SLA 指标，当成功率低于一定程度时需要和负责人绩效挂钩以此来推进产品的稳定性。&lt;/p&gt;
&lt;p&gt;对于网络抖动这种情况，解决的最简单办法之一就是&lt;strong&gt;重试&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;重试机制&#34;&gt;重试机制&lt;/h4&gt;
&lt;h5 id=&#34;重试机制同步-异步模式&#34;&gt;&lt;strong&gt;重试机制：同步 、异步模式&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;原地重试很好理解，就是程序在调用下游服务失败的时候重新发起一次；异步重试是将请求信息丢到某个 mq 中，后续有一个程序消费到这个事件进行重试。&lt;/p&gt;
&lt;p&gt;总的来说，原地重试实现简单，能解决大部分网络抖动问题，但是如果是服务追求强一致性，并且希望在下游故障的时候不影响正常服务计算，这个时候可以考虑用异步重试，上游服务可快速响应用户请求由异步消费者去完成重试。&lt;/p&gt;
&lt;h5 id=&#34;如何防止重试风暴&#34;&gt;如何防止重试风暴&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;单实例限流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们接受请求的是单个实例（进程）中的线程，所以可以以单进程的粒度进行限流。&lt;/p&gt;
&lt;p&gt;关于限流，我们常用的是令牌桶或者滑动窗口两种实现，这里简单实用滑动窗口实现。如下图所示，每秒会产生一个Bucket，我们在Bucket里记录这一秒内对下游某个接口的成功、失败数量。进而可以统计出每秒的失败率，结合失败率及失败请求数判断是否需要重试，每个 Bucket 在一定时间后过期。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/508717682&#34;&gt;https://zhuanlan.zhihu.com/p/508717682&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;dubbo-重试--幂等性-防止重复扣款&#34;&gt;Dubbo 重试  幂等性 防止重复扣款&lt;/h3&gt;
&lt;h5 id=&#34;什么是接口幂等性&#34;&gt;什么是接口幂等性?&lt;/h5&gt;
&lt;p&gt;接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条。这就没有保证接口的幂等性。&lt;/p&gt;
&lt;p&gt;声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。&lt;/p&gt;
&lt;h5 id=&#34;什么情况下需要接口幂等&#34;&gt;什么情况下需要接口幂等?&lt;/h5&gt;
&lt;p&gt;以SQL为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; tab1 &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; col1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; col2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;  &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;无论执行成功多少次状态都是一致的，因此是幂等操作。&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; tab1 &lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; col1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;col1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; col2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;每次执行的结果都会发生变化，这种不是幂等的。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;解决接口幂等性的方案&#34;&gt;解决接口幂等性的方案&lt;/h5&gt;
&lt;p&gt;数据库乐观锁机制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;1.查询数据信息
select customer_id,integral,love_sum,version from customer_addition where id= #{id}
2.根据数据信息是判断当前数据库中的version是否还是刚才查出来的那个version
update customer_addition set integral=integral + 2,version = version+1 where id=#{id} and version= #{version};
3.根据返回修改记录条数来判断当前更新是否生效，如果成功改动0条数据，
  说明version发生了变更，这时候可以根据自己业务逻辑来决定是否需要回滚事务
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果大规模并发下，数据库能扛得住吗？
扛不住呢，只是用这个来演示一下数据库 案例

如果同时执行两个update sql 第一个执行 查询version符合 执行后还未commit，也就是说此时version值还未更新，另一个也执行，查询version也符合，最后两个commit之后 会出现问题 不知道分析得对不对

同时更新同一条记录的时候，update命中索引，会触发行锁，没有命中索引的时候，会触发表锁(意向排它锁)；在有锁的情况下，是不能继续更新的，所以可以规避掉这个问题；^_^
https://zhuanlan.zhihu.com/p/50820372

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  其实发生接口幂等性问题的本质就是多次请求了，解决问题首先从如何避免多次请求，或者判断请求是不是多次请求来出发。&lt;/p&gt;
&lt;p&gt;1 问题分析:&lt;/p&gt;
&lt;p&gt;分布式服务接口的幂等性如何设计（比如不能重复扣款）？&lt;/p&gt;
&lt;p&gt;从这个问题开始，面试官就已经进入了实际的生产问题的面试了。&lt;/p&gt;
&lt;p&gt;一个分布式系统中的某个接口，该如何保证幂等性？这个事儿其实是你做分布式系统的时候必须要考虑的一个生产环境的技术问题。啥意思呢？&lt;/p&gt;
&lt;p&gt;你看，假如你有个服务提供一些接口供外部调用，这个服务部署在了 5 台机器上，接着有个接口就是付款接口。然后人家用户在前端上操作的时候，不知道为啥，总之就是一个订单不小心发起了两次支付请求，然后这俩请求分散在了这个服务部署的不同的机器上，好了，结果一个订单扣款扣两次。&lt;/p&gt;
&lt;p&gt;或者是订单系统调用支付系统进行支付，结果不小心因为网络超时了，然后订单系统走了前面我们看到的那个重试机制，咔嚓给你重试了一把，好，支付系统收到一个支付请求两次，而且因为负载均衡算法落在了不同的机器上，尴尬了。。。&lt;/p&gt;
&lt;p&gt;所以你肯定得知道这事儿，否则你做出来的分布式系统恐怕容易埋坑。&lt;/p&gt;
&lt;p&gt;2 面试题回答:&lt;/p&gt;
&lt;p&gt;这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。&lt;/p&gt;
&lt;p&gt;所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。&lt;/p&gt;
&lt;p&gt;其实保证幂等性主要是三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一标识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​      对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId 作为唯一键。只有成功插入这个支付流水，才可以执行实际的支付扣款。&lt;/p&gt;
&lt;p&gt;要求是支付一个订单，必须插入一条支付流水，order_id 建一个唯一键 unique key。你在支付一个订单之前，先插入一条支付流水，order_id 就已经进去了。你就可以写一个标识到 redis 里面去，set order_id payed，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是 payed 就说明已经支付过了，你就别重复支付了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;方案名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;适用方法&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;实现复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;方案缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据库唯一主键&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;插入操作 删除操作&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简单&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 只能用于插入操作； - 只能用于存在唯一主键场景；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据库乐观锁&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;更新操作&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简单&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 只能用于更新操作； - 表中需要额外添加字段；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求序列号&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;插入操作 更新操作 删除操作&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简单&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 需要保证下游生成唯一序列号； - 需要 Redis 第三方存储已经请求的序列号；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;防重 Token 令牌&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;插入操作 更新操作 删除操作&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;适中&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 需要 Redis 第三方存储生成的 Token 串；&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&#34;https://madridseven.github.io/2019/08/JAVA%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%B9%8BRedis%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/&#34;&gt;Redis-接口的幂等性之Redis解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/m0_50180963/article/details/112853383?spm=1001.2101.3001.6650.18&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-18.pc_relevant_paycolumn_v3&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-18.pc_relevant_paycolumn_v3&amp;amp;utm_relevant_index=27&#34;&gt;阿里面试官：接口的幂等性怎么设计？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/github_38592071/article/details/113623000?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-22-113623000-null-null.pc_agg_new_rank&amp;amp;utm_term=dubbo%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7&amp;amp;spm=1000.2123.3001.4430&#34;&gt;SpringBoot 接口幂等性实现的 4 种方案！这个我真的服气了！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/50820372&#34;&gt;浅谈数据库乐观锁&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%BA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%BA%8C/</guid>
      
        <description>&lt;h1 id=&#34;面试准备二ddd&#34;&gt;面试准备（二）DDD&lt;/h1&gt;
&lt;h3 id=&#34;ddd-domain-driven-design&#34;&gt;DDD Domain-Driven Design&lt;/h3&gt;
&lt;h5 id=&#34;ddd是什么&#34;&gt;DDD是什么？&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  DDD(domain driver design)  是一种业务建模的思想。一个软件的核心价值就是解决业界的核心问题。
  业务模型的好坏直接关系到一个系统的合理性，扩展性，健壮性等等。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;以java/j2ee开发为例，早期有EJB，后来的SSH框架.框架的好处是分层，每一层都负责单一的职责，
但同时也会带来一些问题。例如 ssh的controll-service-dao-bean的分层结构，bean就会有贫血模式的问题，bean只是数据库表的映射，加上getting/setting方法，dao只是负责操作数据库，读写数据，业务方法全部写在service层。这种模式有违OO的原则，对业务扩展也非常不利。所以有必要重新审视。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;什么是领域&#34;&gt;什么是领域？&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我们做一个什么样的系统，这个系统解决什么问题，属于哪个特定的领域？
领域就是问题域，有关键的核心业务，有边界。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;领域模型设计&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;领域模型也是整个系统的核心价值所在
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;领域专家而非产品经理&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;领域建模的基础是要先理解领域，让自己成为领域专家
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;领域划分，拆分&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;理解领域知识是基础
我们需要将领域进行拆分，本质上就是把大问题拆分为小问题
我们该如何划分子域呢？我的个人看法是从业务相关性的角度去思考，也就是我们平时说的按业务功能为出发点进行划分。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需求细化&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1.梳理领域概念：梳理出领域内我们关注的概念、概念的关系，并统一交流词汇，形成统一语言；
2.梳理业务规则：梳理出领域内我们关注的各种业务规则，DDD中叫不变性（invariants），比如唯一性规则，余额不能小于零等；
3.梳理业务场景：梳理出领域内的核心业务场景，比如电商平台中的加入购物车、提交订单、发起付款等核心业务场景；
4.梳理业务流程：梳理出领域内的关键业务流程，比如订单处理流程，退款流程等；

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：上面我说的这四点，重点是梳理出我们要什么功能，而不是思考如何实现这些功能，如何实现是软件设计人员的职责。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;切忌值对象必须是只读的，值对象之所以叫值对象最主要的是因为它表示一个值，而不是一个对象；值是不会变化的，是一个明确含义的不变的事物，比如3表示一个值，表述数量是3，3永远不能变化；所以说，世界之所以存在，是因为有这些永恒不变的值对象的存在；我们只要把值对象理解为3，“abcd”这样的永恒不变的值就行了；

&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;要学习CQRS架构，要知道我们应该将应用程序的业务逻辑处理部分（即用户命令响应部分）和查询部分分离；我们应该用两个不同的技术来实现这两个部分的实现；用DDD领域模型来实现命令部分；用最快的查询引擎来实现查询部分；

&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;那聚合在其中起什么作用呢？
聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果把聚合比作组织，那聚合根就是这个组织的负责人。
聚合根也称为根实体，它不仅是实体，还是聚合的管理者。
最后在聚合之间，它还是聚合对外的接口人，以聚合根 ID 关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根 ID 关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/junzi2099/p/13682086.html&#34;&gt;DDD术语-聚合(Aggregate)、聚合根(AggregateRoot)&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid>
      
        <description>&lt;p&gt;提高技术，掌握核心技术！&lt;/p&gt;
&lt;p&gt;我相信我能干好这个行业！&lt;/p&gt;
&lt;h3 id=&#34;算法&#34;&gt;算法&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/%E8%AF%BB%E4%B9%A6/%E6%9D%8E%E5%85%89%E8%80%80%E8%A7%82%E5%A4%A9%E4%B8%8B-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/%E8%AF%BB%E4%B9%A6/%E6%9D%8E%E5%85%89%E8%80%80%E8%A7%82%E5%A4%A9%E4%B8%8B-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h1 id=&#34;李光耀观天下-读书总结&#34;&gt;李光耀观天下 读书总结&lt;/h1&gt;
&lt;h3 id=&#34;中国&#34;&gt;中国&lt;/h3&gt;
&lt;p&gt;1）中国需要一个强大的中央。&lt;/p&gt;
&lt;p&gt;一个强大的中央会带来一个和平繁荣的中国。&lt;/p&gt;
&lt;p&gt;2）做事不太理会法律和治理制度，是根深蒂固的中国文化。&lt;/p&gt;
&lt;p&gt;3）&lt;/p&gt;
&lt;h3 id=&#34;美国&#34;&gt;美国&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hui305.github.io/post/%E8%AF%BB%E4%B9%A6/%E8%B0%88%E8%AF%9D%E7%9A%84%E5%8A%9B%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hui305.github.io/post/%E8%AF%BB%E4%B9%A6/%E8%B0%88%E8%AF%9D%E7%9A%84%E5%8A%9B%E9%87%8F/</guid>
      
        <description>&lt;h4 id=&#34;封闭式问题-or-开放式问题&#34;&gt;封闭式问题 or 开放式问题&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;不要一直问封闭式问题，不然就变成查户口，FBI询问！
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;问些开放式的问题，兴趣啊，专业啊等等。
要想让谈话继续下去， 并且有一定的深度和趣味， 就要继封闭式问题之
后提出开放式问题
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;最好以简单的问题开始，谈论一些对方感兴趣并且熟悉的话题
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;事先准备一些问题，列清单,记住一些备用问题，实用且有趣
如果你能够成为历史上的某个人物， 你会选择谁？ （对方回答。 ） 为什么？

&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;在选择问题的过程中， 要牢记以下两条： 
第一， 提问题的时候要持愿意倾听的态度。 无论你多么善于交际， 如果你只是冷冷地流于形式， 对方
最终会感觉到你只不过是在设法让他对你产生好感。
第二， 尽量保持双重视角。不仅考虑到自己想听什么、想说什么，还要考虑到对方的需要。最令人讨厌的就是毫不顾及别人的想法和需求。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;称赞&#34;&gt;称赞&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;根据行为认知理论，别人对你的态度在很大程度上取决于你的反应。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;积极回应的最后一点、 也是非常重要的一点原因是， 它们有助于营造一
种开放的、 积极的氛围， 在这种氛围中， 你身边的人能够逐渐成长， 
并认识到他们作为人而具有的潜力。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我们把原来的赞扬具体化一些， 加上对方的名字， 再加上一个问
题， 就是这样： 行为： “艾伦， 我喜欢你在我们练习的时候， 亲自给每
个人做辅导。 说说看， 你观察到的最常犯的错误是什么？ ”
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;积极倾听&#34;&gt;积极倾听&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;要熟练地使用这个技巧，首先要知道，当别人和你说话时，发生着什么样的事情。
上下文 context
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;编码 - 解码
人际交往首先源于个人内心。 对方先是有一些感受或者想法想告诉你。为了传递这个信息， 他首先必须将其转换成语言以及非语言代码，以便你能够理解。至于他选择什么样的代码，什么样的语言和动作，以及说话时的音调， 会由他的目的、 所处环境、和你的关系亲密程度，以及他的年龄、 教育背景、 社会地位、文化背景和感情状况所决定。这个把内心的想法和感受转换成信息的过程被称为编码

对方发出的信息往往与你根据各种信号判断出来的信息有着很大不同。 你的印象往往并不与对方的意图相吻合。
你不应该过分地相信自己的直观感受并以此来行事， 而应当掌握这门技巧， 保证你准确地进行解码， 了解了
对方真正的意图
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>
